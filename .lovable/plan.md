
# Plan: Fix State Style Scoping to Prevent Global Leakage

## Problem Summary

When editing hover, focus, active, or visited styles on a component, the style changes "leak" and affect other unrelated components on the canvas. This happens because the global `currentPseudoState` in `useStyleStore` is used by `getComputedStyles` to compute inline styles for **all** elements, not just the selected component.

### Current Behavior (Broken)
1. User selects a component and switches to "Hover" state in StylePanel
2. `currentPseudoState` is set to `'hover'` globally
3. `getComputedStyles()` is called for ALL components on the canvas
4. Since no explicit `state` parameter is passed, ALL components render their `:hover` styles inline
5. Result: Every component shows its hover state, not just the selected one

### Expected Behavior
- Only the **selected component** should visually preview the current pseudo-state
- All other components should remain in their `default` state
- The CSS generated by `StyleSheetInjector` (e.g., `.my-class:hover`) handles actual browser hover behavior correctly

## Root Cause

In `src/builder/store/useStyleStore.ts` lines 184-195:

```typescript
getComputedStyles: (styleSourceIds, breakpointId, state) => {
  const { styles, breakpoints, currentBreakpointId, currentPseudoState } = get();
  const targetBreakpoint = breakpointId || currentBreakpointId;
  const targetState = state || currentPseudoState;  // ‚Üê PROBLEM: Uses global state if not passed
  // ...
  const stateCascade: PseudoState[] = targetState === 'default' ? ['default'] : ['default', targetState];
```

When components call `getComputedStyles(instance.styleSourceIds)` without passing an explicit `state` parameter, they inherit the global `currentPseudoState`, causing all components to render their pseudo-state styles.

## Solution

Modify the Canvas rendering logic to explicitly pass `'default'` as the state for all components **except** the selected instance, which should use the `currentPseudoState` for preview purposes.

### Approach: Scoped State Preview

The fix needs to:
1. Keep `getComputedStyles` behavior unchanged (it's correct as designed)
2. Update all Canvas rendering calls to explicitly pass the state
3. Only the selected instance should receive `currentPseudoState`; all others get `'default'`

## Files to Modify

### 1. `src/builder/components/Canvas.tsx`

Update the `renderInstance` function to pass the correct state based on selection:

```typescript
// Inside renderInstance or wherever getComputedStyles is called
const { currentPseudoState, getComputedStyles } = useStyleStore();
const { selectedInstanceId } = useBuilderStore();

// For non-selected instances, ALWAYS use 'default' state
const stateToUse = instance.id === selectedInstanceId ? currentPseudoState : 'default';

// Pass state explicitly
const computedStyles = getComputedStyles(instance.styleSourceIds || [], undefined, stateToUse);
```

This pattern needs to be applied wherever `getComputedStyles` is called within Canvas rendering.

### 2. `src/builder/components/TableElements.tsx`

Update `getComputedStyles` calls to pass explicit state:

```typescript
// Before (line 49):
...getComputedStyles(instance.styleSourceIds || []) as React.CSSProperties

// After:
...getComputedStyles(
  instance.styleSourceIds || [], 
  undefined, 
  selectedInstanceId === instance.id ? currentPseudoState : 'default'
) as React.CSSProperties
```

### 3. `src/builder/primitives/DropdownPrimitive.tsx`

Update line 148:

```typescript
// Before:
const computedStyles = useStyleStore.getState().getComputedStyles(instance.styleSourceIds || []);

// After:
const { getComputedStyles, currentPseudoState } = useStyleStore.getState();
const selectedInstanceId = useBuilderStore.getState().selectedInstanceId;
const stateToUse = instance.id === selectedInstanceId ? currentPseudoState : 'default';
const computedStyles = getComputedStyles(instance.styleSourceIds || [], undefined, stateToUse);
```

### 4. All Other Primitives Using `getComputedStyles`

Apply the same pattern to any primitive that calls `getComputedStyles`:
- `ButtonPrimitive.tsx`
- `Text.tsx` 
- `Heading.tsx`
- `LinkPrimitive.tsx`
- Any other primitives that compute styles for canvas rendering

### 5. Helper Components

Update components like:
- `SelectionOverlay.tsx` (line 62)
- `Navigator.tsx` (line 169)
- `data-editors/SeparatorDataEditor.tsx` (line 87)

## Alternative Approach: Centralized Fix

Instead of updating every call site, we could create a wrapper function:

### Create `src/builder/utils/canvasStyles.ts`

```typescript
import { useStyleStore } from '../store/useStyleStore';
import { useBuilderStore } from '../store/useBuilderStore';
import { PseudoState } from '../store/types';

/**
 * Get computed styles for canvas rendering with proper state scoping.
 * Only the selected instance previews the current pseudo-state;
 * all others render in 'default' state.
 */
export function getCanvasComputedStyles(
  instanceId: string,
  styleSourceIds: string[],
  breakpointId?: string
): Record<string, string> {
  const { getComputedStyles, currentPseudoState } = useStyleStore.getState();
  const { selectedInstanceId } = useBuilderStore.getState();
  
  // Only selected instance gets the current pseudo-state preview
  const stateToUse: PseudoState = instanceId === selectedInstanceId 
    ? currentPseudoState 
    : 'default';
  
  return getComputedStyles(styleSourceIds, breakpointId, stateToUse);
}
```

Then update all Canvas rendering to use this helper instead of calling `getComputedStyles` directly.

## Implementation Priority

1. **High Priority**: Update `Canvas.tsx` renderInstance function - this handles most component rendering
2. **Medium Priority**: Update `TableElements.tsx` and `DropdownPrimitive.tsx` - these are commonly used
3. **Lower Priority**: Update `SelectionOverlay.tsx`, `Navigator.tsx`, data editors - these are less visible

## Visual State Indicator

The green highlight for the selected component's state is already handled by:
- `StylePanel.tsx` line 1465: Button styling shows green background when `currentPseudoState !== 'default'`
- This provides clear visual feedback that state editing is active

## Expected Outcome

After this fix:
- Selecting a component and switching to "Hover" state only previews hover styles for **that component**
- All other components remain in their default visual state
- The actual `:hover` CSS generated by `StyleSheetInjector` continues to work correctly for browser hover behavior
- No layout or inheritance issues because default styles are maintained for non-selected elements

## Technical Notes

### CSS Specificity is Already Correct
The `StyleSheetInjector` generates proper class-based pseudo-state selectors:
```css
.my-button { color: blue; }
.my-button:hover { color: red; }
```

This CSS is scoped correctly - the fix is only needed for the **canvas preview** behavior.

### State Cascade Preserved
The fix preserves the state cascade logic (`default` + `targetState`) - it just ensures that only the selected instance uses a non-default state for preview purposes.
